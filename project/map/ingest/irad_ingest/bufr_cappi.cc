//
// fairly stupid BUFR CAPPI class
//

# include <stdlib.h>
# include <errno.h>
# include "bufr_cappi.hh"


bufr_cappi::bufr_cappi( const char* decbufr_txt, const char* decbufr_img )
//
// Initialize, given a text file and image file generated by decbufr.
//
{
    year = month = day = hour = minute = nx = ny = badint;
    xstep = ystep = lat = lon = level = badfloat;

    InitFromDecbufrTxt( decbufr_txt );
    data = new unsigned char[nx * ny];

    FILE *datafile = fopen( decbufr_img, "r" );
    if (! datafile)
    {
	nx = ny = 0;
	data = 0;
    }

    data = new unsigned char[nx * ny];
    int nrows = fread( data, nx, ny, datafile );
    if (nrows != ny)
	fprintf( stderr, "Only got %d of %d data rows from %s\n", nrows, ny,
		 decbufr_img );

    fclose( datafile );
}




bufr_cappi::~bufr_cappi( void )
{
    delete[] data;
}



void 
bufr_cappi::InitFromDecbufrTxt( const char* decbufr_txt )
//
// Unpack everything we need from a decbufr text output file.  This is all
// very hard-wired to the content used for Italian operational radar BUFR 
// files.
//
{
    char line[128];
    float fval;

    FILE *txtfile = fopen( decbufr_txt, "r" );
    if (! txtfile)
    {
	fprintf( stderr, "Error %d opening decbufr text file %s\n", errno,
		 decbufr_txt );
	return;
    }
//
// date/time
//
    year = NextIVal( txtfile );
    month = NextIVal( txtfile );
    day = NextIVal( txtfile );
    hour = NextIVal( txtfile );
    minute = NextIVal( txtfile );
//
// image size
//
    ny = NextIVal( txtfile );
    nx = NextIVal( txtfile );
    ystep = NextFVal( txtfile );	// meters
    xstep = NextFVal( txtfile );	// meters
//
// 256 value lookup table [first value, then count (should be 255), 
// then remaining values]
//
    table[0] = NextFVal( txtfile );
    int count = NextIVal( txtfile );
    if (count != 255)
    {
	fprintf( stderr, "Bad lookup table length %d (expecting 255)\n",
		 count );
	fclose( txtfile );
	return;
    }
    for (int i = 1; i < 256; i++)
	table[i] = NextFVal( txtfile );
//
// location
//
    lat = NextFVal( txtfile );
    lon = NextFVal( txtfile );
    alt = NextFVal( txtfile );
//
// CAPPI height
//
    level = NextFVal( txtfile );	// meters

    fclose( txtfile );
}



int
bufr_cappi::NextIVal( FILE *txtfile )
//
// Read the next line from decbufr text file txtfile and return the integer
// value from the line
//
{
    return( (int)NextFVal( txtfile ) );
}



float
bufr_cappi::NextFVal( FILE *txtfile )
//
// Read the next line from decbufr text file txtfile and return the floating
// point value from the line
//
{
    char line[128];
    float fval;

    fgets( line, sizeof( line ), txtfile );
    sscanf( line + 9, "%f", &fval );
    return( fval );
}

    

time_t
bufr_cappi::Time( void ) const
//
// Return the data time as a Unix time_t (seconds since 1 Jan 1970 00:00 UTC)
//
{
    struct tm ts;

    ts.tm_sec = 0;
    ts.tm_min = minute;
    ts.tm_hour = hour;
    ts.tm_mday = day;
    ts.tm_mon = month - 1;
    ts.tm_year = year - 1900;
    ts.tm_wday = -1;
    ts.tm_yday = -1;
    ts.tm_isdst = -1;

    putenv( "TZ=GMT" );
    return( mktime( &ts ) );
}


void 
bufr_cappi::DoubleRes( void )
//
// Double our effective resolution by replicating data values in both x and y.
// Hence we double nx and ny, and halve xstep and ystep.
//
{
    int old_nx = nx;
    int old_ny = ny;
    unsigned char* old_data = data;

    nx *= 2;
    ny *= 2;
    xstep /= 2;
    ystep /= 2;
    data = new unsigned char[nx * ny];

    for (int j = 0; j < old_ny; j++)
    {
	for (int i = 0; i < old_nx; i++)
	{
	    unsigned char* dp = data + (2 * j) * nx + (2 * i);
	    unsigned char val = old_data[j * old_nx + i];

	    dp[0] = val;
	    dp[1] = val;
	    dp[nx] = val;
	    dp[nx + 1] = val;
	}
    }

    delete[] old_data;
}



void 
bufr_cappi::DoubleSize( void )
//
// Double our array size by inserting a wide border of zero data around the
// existing array.  This doubles nx and ny.
//
{
    int old_nx = nx;
    int old_ny = ny;
    unsigned char* old_data = data;

    nx *= 2;
    ny *= 2;
    data = new unsigned char[nx * ny];
//
// Zero fill the entire new array
//
    for (which = 0; which < nx * ny; which++)
	data[which] = 0;
//
// Copy the old data into the middle of the array
//
    for (int j = 0; j < old_ny; j++)
    {
	for (int i = 0; i < old_nx; i++)
	{
	    unsigned char* dp = data + (ny / 4 + j) * nx + (nx / 4) + i;
	    unsigned char val = old_data[j * old_nx + i];

	    *dp = val;
	}
    }

    delete[] old_data;
}
